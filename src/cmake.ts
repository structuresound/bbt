/*  eslint no-template-curly-in-string: "off"*/
import * as _ from 'lodash';
import * as Promise from 'bluebird';
import * as path from 'path';
import * as sh from 'shelljs';
import * as fs from 'fs';
import { arrayify, check } from 'js-object-tools';

import { updateNode, updateEnvironment } from './db';
import { fileHash } from './util/hash';
import { log } from './util/log';

import { startsWith } from './util/string';
import { fetch } from './tools';
import file from './file';

interface CMakeDefines {
  [index: string]: string;
}

interface Toolpaths {
  ninja: string;
}

function doConfiguration(env: Environment, ninja: string) {
  const defines = env.configure.cmake ? env.configure.cmake.defines || {} : {};
  const cMakeDefines: CMakeDefines = _.extend({
    LIBRARY_OUTPUT_PATH: env.d.install.libraries[0].from
  }, defines);
  let command = `cmake -G Ninja -DCMAKE_MAKE_PROGRAM=${ninja} ${env.d.project}`;
  for (const k of Object.keys(cMakeDefines)) {
    let value = cMakeDefines[k];
    if (typeof value === 'string' || value instanceof String) {
      if (startsWith(value, '~/')) {
        value = `${env
          .d
          .home}/${value
            .slice(2)}`;
      }
    }
    command += ` -D${k}=${value}`;
  }
  return cmake(env, command);
}

function cmake(env: Environment, command: string) {
  log.quiet(command);
  return new Promise((resolve, reject) => {
    sh.cd(env.d.build);
    return sh.exec(command, (code, stdout, stderr) => {
      if (code) {
        return reject(new Error(`cmake exited with code ${code}\nfull command: ${command} \nfolder: ${env.d.build}`));
      } else if (stdout) {
        return resolve(stdout);
      } else if (stderr) {
        return resolve(stderr);
      }
    });
  });
}

function configure(env: Environment) {
  const buildFilePath = path.join(env.d.project, );
  return fileHash(buildFilePath).then((buildFileHash) => {
    if (!env.cache.buildFile.dirty(buildFileHash)) {
      return Promise.resolve();
    }
    return fetch(env.tools).then((toolpaths: Toolpaths) => {
      return doConfiguration(env, toolpaths.ninja).then(() => {
        return updateEnvironment(env, {
          $set: {
            'cache.buildFile': buildFileHash
          }
        });
      });
    });
  });
}

function build(env: Environment) {
  return configure(env).then(() => {
    const hostChain = env.tools;
    return fetch(hostChain).then((toolpaths: Toolpaths) => {
      return cmake(env, `${toolpaths.ninja}`);
    });
  });
}

function cmakeArrayToQuotedList(array: string[]) {
  return _.map(array, (el) => {
    return `"${el}"`;
  }).join(' ');
}

function header(env: Environment): string {
  let pv = env.project.version || '0.0.1';
  if (startsWith(pv, 'v')) {
    pv = pv.slice(1);
  }
  return `# generated by trieMake
cmake_minimum_required(VERSION ${env.build.cmake
      ? env.build.cmake.minimumVersion
      : '3.2'})
project(${env.project.name} VERSION ${pv})`;
}

function includeDirectories(env: Environment): string {
  switch (env.outputType) {
    case 'static':
    case 'dynamic':
    case 'executable':
    default:
      return `\n
        include_directories(${cmakeArrayToQuotedList(env.includeDirs())})`;
    case 'env':
      return `\n
        # Essential include files to build a env addon,
        # you should add this line in every CMake.js based project.
        include_directories(\${CMAKE_JS_INC})
        include_directories(${cmakeArrayToQuotedList(env.includeDirs())})`;
  }
}

function sources(env: Environment): string {
  return `\n
    set(SOURCE_FILES \${SOURCE_FILES} ${cmakeArrayToQuotedList(env.s)})`;
}

function flags(env: Environment): string {
  const cxxFlags = env.cxxFlags().join(' ');
  return `\n
    set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} ${cxxFlags}")
    set(CMAKE_C_FLAGS "\${CMAKE_C_FLAGS} ${env
      .cFlags()
      .join(' ')}")`;
}

function assets(env: Environment): string {
  let copy = '';
  if (env.build.cmake && env.build.cmake.copy) {
    _.each(arrayify(env.build.cmake.copy), (ft) => {
      if (fs.existsSync(`${env.d.project}/${ft.from}`)) {
        copy += `\nfile(COPY \${CMAKE_CURRENT_SOURCE_DIR}/${ft.from} DESTINATION \${CMAKE_CURRENT_BINARY_DIR}/${ft.to})`;
      }
      throw new Error(`@CMake gen -> file doesn't exist @ ${env.d.project}/${ft.from}`);
    });
  }
  return copy;
}

function target(env: Environment): string {
  switch (env.outputType) {
    case 'static':
    default:
      return `\nadd_library(${env.project.name} STATIC \${SOURCE_FILES})`;
    case 'executable':
      return `\nadd_executable(${env.project.name} \${SOURCE_FILES})`;
  }
}

function link(env: Environment): string {
  let libs = cmakeArrayToQuotedList(env.project.libs);
  const frameworks = cmakeArrayToQuotedList(env.frameworks());
  if (libs.length || frameworks.length) {
    return `\ntarget_link_libraries(\${PROJECT_NAME} ${libs} ${frameworks} ${env
      .linkerFlags()
      .join(' ')})`;
  }
  return '';
}

function generate(env: Environment) {
  const b = env.build;

  // for (const filePath of env.s) {
  //   // console.log 'process source file', filePath
  //   const dir = path.dirname(filePath);
  //   const relative = path.relative(env.p.clone, dir);
  //   // console.log 'relative from #{env.p.clone} is #{relative}'
  //   const outBase = path.join('build', relative);
  //   const ext = path.extname(filePath);
  //   const name = path.basename(filePath, ext);
  //   const linkName = `${outBase}/${name}.o`;
  //   // console.log 'add build file', linkName
  //   ninjaConfig
  //     .edge(linkName)
  //     .from(filePath)
  //     .using(getRule(ext));
  //   linkNames.push(linkName);
  // };ÃŽ

  return header(env) +
    includeDirectories(env) +
    sources(env) +
    flags(env) +
    target(env) +
    link(env) +
    assets(env)
}

export { generate, configure, build };

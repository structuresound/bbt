/*  eslint no-template-curly-in-string: "off"*/
import * as _ from 'lodash';
import * as Bluebird from 'bluebird';
import * as path from 'path';
import { existsSync } from 'fs';
import { arrayify, check } from 'js-object-tools';

import { updateProject, updateEnvironment } from './db';
import { fileHash } from './hash';
import { log } from './log';

import { startsWith } from './string';
import { fetch } from './tools';
import { execAsync } from './sh';
import { args } from './args';
import { Environment } from './environment';

import { ensureBuildFile } from './build';

interface CMakeDefines {
  [index: string]: string;
}

interface Toolpaths {
  ninja: string;
}

function doConfiguration(env: Environment, ninja: string) {
  const defines = env.build.defines ? env.build.defines || {} : {};
  const cMakeDefines: CMakeDefines = _.extend({
    LIBRARY_OUTPUT_PATH: env.d.install.libraries[0].from
  }, defines);
  let command = `cmake -G Ninja -DCMAKE_MAKE_PROGRAM=${ninja} ${env.d.project}`;
  for (const k of Object.keys(cMakeDefines)) {
    let value = cMakeDefines[k];
    if (typeof value === 'string' || value instanceof String) {
      if (startsWith(value, '~/')) {
        value = `${env.project
          .d
          .home}/${value
            .slice(2)}`;
      }
    }
    command += ` -D${k}=${value}`;
  }
  return cmake(env, command);
}

function cmake(env: Environment, command: string) {
  const wd = env.d.build;
  log.verbose(command);
  return execAsync(command, {
    cwd: wd,
    silent: !args.verbose,
    short: 'cmake'
  });
}

function configure(env: Environment) {
  const ninjaFile = path.join(env.d.build, 'build.ninja');
  return fileHash(ninjaFile).then((buildFileHash) => {
    if (existsSync(ninjaFile) && env.cache.cmake.value() === buildFileHash) {
      return Promise.resolve();
    }
    return fetch(env.tools).then((toolpaths: Toolpaths) => {
      return doConfiguration(env, toolpaths.ninja).then(() => {
        env.cache.cmake.update();
        return updateEnvironment(env);
      });
    });
  });
}

function build(env: Environment) {
  return configure(env).then(() => {
    const hostChain = env.tools;
    return fetch(hostChain).then((toolpaths: Toolpaths) => {
      ensureBuildFile(env, 'cmake');
      return cmake(env, `${toolpaths.ninja}`);
    });
  });
}

function cmakeArrayToQuotedList(array: string[]) {
  return _.map(array, (el) => {
    return `"${el}"`;
  }).join(' ');
}

function header(env: Environment): string {
  let pv = env.project.version || '0.0.1';
  if (startsWith(pv, 'v')) {
    pv = pv.slice(1);
  }
  const version = env.configure.cmake ? env.configure.cmake.minimumVersion : '3.2';
  return `
# generated by trieMake
cmake_minimum_required(VERSION ${version})
project(${env.project.name} VERSION ${pv})`;
}

function includeDirectories(env: Environment): string {
  switch (env.outputType) {
    case 'static':
    case 'dynamic':
    case 'executable':
    default:
      return `
include_directories(${cmakeArrayToQuotedList(env.includeDirs())})`;
    case 'env':
      return `
# Essential include files to build a env addon,
# you should add this line in every CMake.js based project.
include_directories(\${CMAKE_JS_INC})
include_directories(${cmakeArrayToQuotedList(env.includeDirs())})`;
  }
}

function matching(env: Environment): string {
  const relativeToSource = path.relative(env.d.project, env.d.source) || '.';
  const src = _.map(env.s, (fp) => {
    console.log(path.join(relativeToSource, fp));
    return path.join(relativeToSource, fp);
  })
  return `\n
set(SOURCE_FILES \${SOURCE_FILES} ${cmakeArrayToQuotedList(src)})`;
}

function flags(env: Environment): string {
  const cxxFlags = env.cxxFlags().join(' ');
  return `
set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} ${cxxFlags}")
set(CMAKE_C_FLAGS "\${CMAKE_C_FLAGS} ${env.cFlags().join(' ')}")`;
}

function assets(env: Environment): string {
  let copy = '';
  if (env.configure.cmake && env.configure.cmake.copy) {
    _.each(arrayify(env.configure.cmake.copy), (ft) => {
      if (existsSync(`${env.d.project}/${ft.from}`)) {
        copy += `\nfile(COPY \${CMAKE_CURRENT_SOURCE_DIR}/${ft.from} DESTINATION \${CMAKE_CURRENT_BINARY_DIR}/${ft.to})`;
      }
      throw new Error(`@CMake gen -> file doesn't exist @ ${env.d.project}/${ft.from}`);
    });
  }
  return copy;
}

function target(env: Environment): string {
  switch (env.outputType) {
    case 'static':
    default:
      return `\nadd_library(${env.project.name} STATIC \${SOURCE_FILES})`;
    case 'executable':
      return `\nadd_executable(${env.project.name} \${SOURCE_FILES})`;
  }
}

function link(env: Environment): string {
  let linkLibs = cmakeArrayToQuotedList(env.build.libs.reverse());
  const frameworks = cmakeArrayToQuotedList(env.frameworks());
  if (linkLibs.length || frameworks.length) {
    return `
target_link_libraries(\${PROJECT_NAME} ${linkLibs} ${frameworks} ${env.linkerFlags().join(' ')})
`;
  }
  return '';
}

function generate(env: Environment) {
  return header(env) +
    includeDirectories(env) +
    matching(env) +
    flags(env) +
    target(env) +
    link(env) +
    assets(env)
}

export { generate, configure, build };

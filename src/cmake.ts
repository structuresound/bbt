/*  eslint no-template-curly-in-string: "off"*/
import * as _ from 'lodash';
import * as Promise from 'bluebird';
import * as path from 'path';
import * as sh from 'shelljs';
import * as fs from 'fs';
import { diff, check } from 'js-object-tools';

import { updateNode } from './db';
import { fileHash } from './util/hash';
import log from './util/log';

import { startsWith } from './util/string';
import { fetch } from './toolchain';

import { Node } from './node';
import file from './util/file';

interface CMakeDefines {
  [index: string]: string;
}

interface Toolpaths {
  ninja: string;
}

function doConfiguration(node: Node, ninja: string) {
  const cMakeDefines: CMakeDefines = _.extend({
    LIBRARY_OUTPUT_PATH: node.d.install.libraries[0].from
  }, (node.configure || <file.BuildSettings>{}).defines);
  let command = `cmake -G Ninja -DCMAKE_MAKE_PROGRAM=${ninja} ${node.d.project}`;
  Object
    .keys(cMakeDefines)
    .forEach((key) => {
      let value = cMakeDefines[key];
      if (typeof value === 'string' || value instanceof String) {
        if (startsWith(value, '~/')) {
          value = `${node
            .d
            .home}/${value
              .slice(2)}`;
        }
      }
      command += ` -D${key}=${value}`;
    });
  return cmake(node, command);
}

function cmake(node: Node, command: string) {
  log.quiet(command);
  return new Promise((resolve, reject) => {
    sh.cd(node.d.build);
    return sh.exec(command, (code, stdout, stderr) => {
      if (code) {
        return reject(new Error(`cmake exited with code ${code}\nfull command: ${command} \nfolder: ${node.d.build}`));
      } else if (stdout) {
        return resolve(stdout);
      } else if (stderr) {
        return resolve(stderr);
      }
    });
  });
}

function configure(node: Node) {
  const buildFile = path.join(node.d.project, node.cache.buildFile);
  return fileHash(buildFile).then((configHash) => {
    if (node.cache.configuration === configHash) {
      return Promise.resolve();
    }
    return fetch(node.toolchain).then((toolpaths: Toolpaths) => {
      return doConfiguration(node, toolpaths.ninja).then(() => {
        return updateNode(node, {
          $set: {
            'cache.configuration': configHash
          }
        });
      });
    });
  });
}

function build(node: Node) {
  return configure(node).then(() => {
    const hostChain = node.toolchain;
    return fetch(hostChain).then((toolpaths: Toolpaths) => {
      return cmake(node, `${toolpaths.ninja}`);
    });
  });
}

function cmakeArrayToQuotedList(array: string[]) {
  return _.map(array, (el) => {
    return `"${el}"`;
  }).join(' ');
}

function header(node: Node): string {
  let pv = node.version || '0.0.1';
  if (startsWith(pv, 'v')) {
    pv = pv.slice(1);
  }
  return `# generated by trieMake
cmake_minimum_required(VERSION ${node.configuration.cmake
      ? node.configuration.cmake.minimumVersion
      : '3.2'})
project(${node.name} VERSION ${pv})`;
}

function includeDirectories(node: Node): string {
  switch (node.outputType) {
    case 'static':
    case 'dynamic':
    case 'executable':
    default:
      return `\n
        include_directories(${cmakeArrayToQuotedList(node.includeDirs())})`;
    case 'node':
      return `\n
        # Essential include files to build a node addon,
        # you should add this line in every CMake.js based project.
        include_directories(\${CMAKE_JS_INC})
        include_directories(${cmakeArrayToQuotedList(node.includeDirs())})`;
  }
}

function sources(node: Node): string {
  return `\n
    set(SOURCE_FILES \${SOURCE_FILES} ${cmakeArrayToQuotedList(node.s)})`;
}

function flags(node: Node): string {
  const cxxFlags = node.cxxFlags().join(' ');
  return `\n
    set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} ${cxxFlags}")
    set(CMAKE_C_FLAGS "\${CMAKE_C_FLAGS} ${node
      .cFlags()
      .join(' ')}")`;
}

function assets(node: Node): string {
  let copy = '';
  if (node.build.cmake && node.build.cmake.copy) {
    _.each(diff.arrayify(node.build.cmake.copy), (ft) => {
      if (fs.existsSync(`${node.d.project}/${ft.from}`)) {
        copy += `\nfile(COPY \${CMAKE_CURRENT_SOURCE_DIR}/${ft.from} DESTINATION \${CMAKE_CURRENT_BINARY_DIR}/${ft.to})`;
      }
      throw new Error(`@CMake gen -> file doesn't exist @ ${node.d.project}/${ft.from}`);
    });
  }
  return copy;
}

function target(node: Node): string {
  switch (node.outputType) {
    case 'static':
    default:
      return `\nadd_library(${node.name} STATIC \${SOURCE_FILES})`;
    case 'executable':
      return `\nadd_executable(${node.name} \${SOURCE_FILES})`;
  }
}

function link(node: Node): string {
  let libs = cmakeArrayToQuotedList(node.libs);
  const frameworks = cmakeArrayToQuotedList(node.frameworks());
  if (libs.length || frameworks.length) {
    return `\ntarget_link_libraries(\${PROJECT_NAME} ${libs} ${frameworks} ${node
      .linkerFlags()
      .join(' ')})`;
  }
  return '';
}

function generate(node: Node) {
  const c = node.configuration;

  // for (const filePath of node.s) {
  //   // console.log 'process source file', filePath
  //   const dir = path.dirname(filePath);
  //   const relative = path.relative(node.p.clone, dir);
  //   // console.log 'relative from #{node.p.clone} is #{relative}'
  //   const outBase = path.join('build', relative);
  //   const ext = path.extname(filePath);
  //   const name = path.basename(filePath, ext);
  //   const linkName = `${outBase}/${name}.o`;
  //   // console.log 'add build file', linkName
  //   ninjaConfig
  //     .edge(linkName)
  //     .from(filePath)
  //     .using(getRule(ext));
  //   linkNames.push(linkName);
  // };ÃŽ

  return header(node) +
    includeDirectories(node) +
    sources(node) +
    flags(node) +
    target(node) +
    link(node) +
    assets(node)
}

export { generate, configure, build };

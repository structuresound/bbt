/*  eslint no-template-curly-in-string: "off"*/
import _ from 'lodash';
import Promise from 'bluebird';
import path from 'path';
import sh from 'shelljs';
import {diff} from 'js-object-tools';

import fs from 'fs';

import {updateNode} from './db';
import {fileHash} from './util/hash';
import log from './util/log';

import {startsWith} from './util/string';
import {fetch} from './toolchain';

function doConfiguration(node, ninja) {
  const cMakeDefines = _.extend({
    LIBRARY_OUTPUT_PATH: node.d.install.libraries[0].from
  }, (node.configure || {}).defines);
  let command = `cmake -G Ninja -DCMAKE_MAKE_PROGRAM=${ninja} ${node.d.project}`;
  Object
    .keys(cMakeDefines)
    .forEach((key) => {
      let value = cMakeDefines[key];
      if (typeof value === 'string' || value instanceof String) {
        if (startsWith(value, '~/')) {
          value = `${node
            .d
            .home}/${value
            .slice(2)}`;
        }
      }
      command += ` -D${key}=${value}`;
    });
  return cmake(node, command);
}

function cmake(node, command) {
  log.quiet(command);
  return new Promise((resolve, reject) => {
    sh.cd(node.d.build);
    return sh.exec(command, (code, stdout, stderr) => {
      if (code) {
        return reject(new Error(`cmake exited with code ${code}\nfull command: ${command} \nfolder: ${node.d.build}`));
      } else if (stdout) {
        return resolve(stdout);
      } else if (stderr) {
        return resolve(stderr);
      }
    });
  });
}

function configure(node) {
  const buildFile = path.join(node.d.project, node.cache.buildFile);
  return fileHash(buildFile).then((configHash) => {
    if (node.cache.configuration === configHash) {
      return Promise.resolve();
    }
    return fetch(node.toolchain).then((toolpaths) => {
      return doConfiguration(node, toolpaths.ninja).then(() => {
        return updateNode(node, {
          $set: {
            'cache.configuration': configHash
          }});
      });
    });
  });
}

function build(node) {
  return configure(node).then(() => {
    const hostChain = node.toolchain;
    return fetch(hostChain).then((toolpaths) => {
      return cmake(node, `${toolpaths.ninja}`);
    });
  });
}

function cmakeArrayToQuotedList(array) {
  _.map(array, (el) => {
    return `"${el}"`;
  }).join(' ');
}

function header() {
  return `# generated by trieMake
cmake_minimum_required(VERSION ${this.cmake
    ? this.cmake.minimumVersion
    : '3.2'})
project(${this.name} VERSION ${this.version || '0.0.1'})`;
}

function boost() {
  if (this.boost) {
    if (typeof this.boost === 'string' || this.boost instanceof String) {
      this.boost = {
        libs: [this.boost]
      };
    }
    return `\n
      # Include BoostLib module
      SET(CMAKE_MODULE_PATH '${path.join(this.npmDir, 'node_modules/boost-lib/cmake')}') include(BoostLib) # Locate/Download Boost (semver) require_boost_libs('${this.boost.version || '>= 1.59.0'}' '${this
      .boost
      .libs
      .join(';')}')
      include_directories(\${Boost_INCLUDE_DIRS})`;
  }
}

function includeDirectories() {
  switch (this.outputType) {
    case 'static':
    case 'dynamic':
    case 'executable':
    default:
      return `\n
        include_directories(${cmakeArrayToQuotedList(this.includeDirs)})`;
    case 'node':
      return `\n
        # Essential include files to build a node addon,
        # you should add this line in every CMake.js based project.
        include_directories(\${CMAKE_JS_INC})
        include_directories(${cmakeArrayToQuotedList(this.includeDirs)})`;
  }
}

function sources() {
  return `\n
    set(SOURCE_FILES \${SOURCE_FILES} ${cmakeArrayToQuotedList(this.sources)})`;
}

function flags() {
  return `\n
    set(CMAKE_CXX_FLAGS '\${CMAKE_CXX_FLAGS} ${this
    .cxxFlags
    .join(' ')}')
    set(CMAKE_C_FLAGS '\${CMAKE_C_FLAGS} ${this
    .cFlags
    .join(' ')}')`;
}

function assets(node) {
  let copy = '';
  if ((node.build.cmake || {}).copy) {
    _.each(diff.arrayify(node.build.cmake.copy), (ft) => {
      if (fs.existsSync(`${node.d.project}/${ft.from}`)) {
        copy += `\nfile(COPY \${CMAKE_CURRENT_SOURCE_DIR}/${ft.from} DESTINATION \${CMAKE_CURRENT_BINARY_DIR}/${ft.to})`;
      }
      throw new Error(`@CMake gen -> file doesn't exist @ ${node.d.project}/${ft.from}`);
    });
  }
  return copy;
}

function target() {
  switch (this.outputType) {
    case 'static':
    default:
      return `\nadd_library(${this.name} STATIC \${SOURCE_FILES})`;
    case 'executable':
      return `\nadd_executable(${this.name} \${SOURCE_FILES})`;
  }
}

function link() {
  let libs = cmakeArrayToQuotedList(this.libs);
  const frameworks = cmakeArrayToQuotedList(this.frameworks);
  if (this.boost) {
    libs += ' ${Boost_LIBRARIES}';
  }
  if (libs.length) {
    return `\ntarget_link_libraries(\${PROJECT_NAME} ${libs} ${frameworks} ${this
      .linkerFlags
      .join(' ')})`;
  }
}

function generateLists(funcs, context) {
  let list = '';
  return Promise.each(funcs, fn => {
    return Promise
      .resolve(fn.bind(context)())
      .then((val) => {
        if (val) {
          list += val;
        }
        return Promise.resolve();
      });
  }).then(() => {
    return Promise.resolve(list);
  });
}

function generate(node) {
  return generateLists([
    header,
    boost,
    includeDirectories,
    sources,
    flags,
    target,
    link,
    assets
  ], node.configuration);
}

export {generate, configure, build};

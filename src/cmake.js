/*  eslint no-template-curly-in-string: "off"*/
import _ from 'lodash';
import Promise from 'bluebird';
import path from 'path';
import sh from 'shelljs';
import {diff} from 'js-object-tools';

import fs from './util/fs';
import ninja from './ninja';
import {fileHash} from './util/hash';
import log from './util/log';
import {cache as db} from './db';
import {startsWith} from './util/string';

function run(dep, ninjaPath) {
  const command = ninjaPath;
  log.quiet(command);
  return new Promise((resolve, reject) => {
    sh.cd(dep.d.build);
    return sh.exec(command, (code, stdout, stderr) => {
      if (code) {
        return reject(new Error(`cmake exited with code ${code}\nfull command: ${command} \nfolder: ${dep.d.build}`));
      } else if (stdout) {
        return resolve(stdout);
      } else if (stderr) {
        return resolve(stderr);
      }
    });
  });
}

function doConfiguration(dep, ninjaPath) {
  const cMakeDefines = _.extend({
    LIBRARY_OUTPUT_PATH: dep.d.install.libraries[0].from
  }, (dep.configure || {}).defines);
  let command = `cmake -G Ninja -DCMAKE_MAKE_PROGRAM=${ninjaPath} ${dep.d.project}`;
  Object
    .keys(cMakeDefines)
    .forEach((key) => {
      let value = cMakeDefines[key];
      if (typeof value === 'string' || value instanceof String) {
        if (startsWith(value, '~/')) {
          value = `${dep
            .d
            .home}/${value
            .slice(2)}`;
        }
      }
      command += ` -D${key}=${value}`;
    });
  log.quiet(command);
  return run(command);
}

function configure(dep, ninjaPath) {
  const buildFile = path.join(dep.d.project, dep.cache.buildFile);
  return fileHash(buildFile).then((configHash) => {
    if (dep.cache.configuration === configHash) {
      return Promise.resolve();
    }
    return doConfiguration(ninjaPath).then(() => {
      return db.update({
        name: dep.name
      }, {
        $set: {
          'cache.configuration': configHash
        }
      });
    });
  });
}

function cmakeArrayToQuotedList(array) {
  _.map(array, (el) => {
    return `"${el}"`;
  }).join(' ');
}

function header() {
  return `# generated by trieMake
cmake_minimum_required(VERSION ${this.cmake
    ? this.cmake.minimumVersion
    : '3.2'})
project(${this.name} VERSION ${this.version || '0.0.1'})`;
}

function boost() {
  if (this.boost) {
    if (typeof this.boost === 'string' || this.boost instanceof String) {
      this.boost = {
        libs: [this.boost]
      };
    }
    return `\n
      # Include BoostLib module
      SET(CMAKE_MODULE_PATH '${path.join(this.npmDir, 'node_modules/boost-lib/cmake')}') include(BoostLib) # Locate/Download Boost (semver) require_boost_libs('${this.boost.version || '>= 1.59.0'}' '${this
      .boost
      .libs
      .join(';')}')
      include_directories(\${Boost_INCLUDE_DIRS})`;
  }
}

function includeDirectories() {
  switch (this.target) {
    case 'static':
    case 'dynamic':
    case 'bin':
    default:
      return `\n
        include_directories(${cmakeArrayToQuotedList(this.includeDirs)})`;
    case 'node':
      return `\n
        # Essential include files to build a node addon,
        # you should add this line in every CMake.js based project.
        include_directories(\${CMAKE_JS_INC})
        include_directories(${cmakeArrayToQuotedList(this.includeDirs)})`;
  }
}

function sources() {
  return `\n
    set(SOURCE_FILES \${SOURCE_FILES} ${cmakeArrayToQuotedList(this.sources)})`;
}

function flags() {
  return `\n
    set(CMAKE_CXX_FLAGS '\${CMAKE_CXX_FLAGS} ${this
    .cxxFlags
    .join(' ')}')
    set(CMAKE_C_FLAGS '\${CMAKE_C_FLAGS} ${this
    .cFlags
    .join(' ')}')`;
}

function assets(dep) {
  let copy = '';
  if ((dep.build.cmake || {}).copy) {
    _.each(diff.arrayify(dep.build.cmake.copy), (ft) => {
      if (fs.existsSync(`${dep.d.project}/${ft.from}`)) {
        copy += `\nfile(COPY \${CMAKE_CURRENT_SOURCE_DIR}/${ft.from} DESTINATION \${CMAKE_CURRENT_BINARY_DIR}/${ft.to})`;
      }
      throw new Error(`@CMake gen -> file doesn't exist @ ${dep.d.project}/${ft.from}`);
    });
  }
  return copy;
}

function target() {
  switch (this.target) {
    case 'static':
    default:
      return `\nadd_library(${this.name} STATIC \${SOURCE_FILES})`;
    case 'bin':
      return `\nadd_executable(${this.name} \${SOURCE_FILES})`;
  }
}

function link() {
  let libs = cmakeArrayToQuotedList(this.libs);
  const frameworks = cmakeArrayToQuotedList(this.frameworks);
  if (this.boost) {
    libs += ' ${Boost_LIBRARIES}';
  }
  if (this.target === 'node') {
    libs += ' ${CMAKE_JS_LIB}';
  }
  if (libs.length) {
    return `\ntarget_link_libraries(\${PROJECT_NAME} ${libs} ${frameworks} ${this
      .linkerFlags
      .join(' ')})`;
  }
}

function generateLists(funcs, context) {
  let list = '';
  return Promise.each(funcs, fn => {
    return Promise
      .resolve(fn.bind(context)())
      .then((val) => {
        if (val) {
          list += val;
        }
        return Promise.resolve();
      });
  }).then(() => {
    return Promise.resolve(list);
  });
}

export default {
  generate(dep) {
    return generateLists([
      header,
      boost,
      includeDirectories,
      sources,
      flags,
      target,
      link,
      assets
    ], dep.configuration);
  },
  configure(dep) {
    return ninja
      .getNinja()
      .then(ninjaPath => {
        return configure(dep, ninjaPath);
      });
  },
  build(dep) {
    return ninja
      .getNinja()
      .then(ninjaPath => {
        return configure(dep, ninjaPath).then(() => {
          return run(dep, ninjaPath);
        });
      });
  }
};

import _ from 'underscore';
import Promise from 'bluebird';
import fs from '../util/fs';
import arrayify from '../util/arrayify';
import path from 'path';
import sh from 'shelljs';
import colors from 'chalk';
import ninja from './ninja';
import {fileHash} from '../util/hash';
import log from '../util/log';

if (!db) {
  throw new Error("no db provided to cmake");
}

const run = function(ninjaPath) {
  const command = ninjaPath;
  log.quiet(command);
  return new Promise(function(resolve, reject) {
    sh.cd(dep.d.build);
    return sh.exec(command, function(code, stdout, stderr) {
      if (code) {
        return reject(new Error(`cmake exited with code ${code}\nfull command: ${command} \nfolder: ${dep.d.build}`));
      } else if (stdout) {
        return resolve(stdout);
      } else if (stderr) {
        return resolve(stderr);
      }
    });
  });
};

const doConfiguration = function(ninjaPath) {
  const cMakeDefines = _.extend({
    LIBRARY_OUTPUT_PATH: dep.d.install.libraries[0].from
  }, __guard__(dep.configure, x => x.defines));
  const command = `cmake -G Ninja -DCMAKE_MAKE_PROGRAM=${ninjaPath} ${dep.d.project}`;
  _.each(cMakeDefines, function(value, key) {
    if (typeof value === 'string' || value instanceof String) {
      if (value.startsWith('~/')) {
        value = `${dep.d.home}/${value.slice(2)}`;
      }
    }
    return command += ` -D${key}=${value}`;
  });
  log.quiet(command);
  return run(command);
};

const configure = function(ninjaPath) {
  const buildFile = path.join(dep.d.project, dep.cache.buildFile);
  return fileHash(buildFile).then(function(configHash) {
    if (dep.cache.configuration === configHash) {
      return Promise.resolve();
    } else {
      return doConfiguration(ninjaPath).then(() => db.update({
        name: dep.name
      }, {
        $set: {
          "cache.configuration": configHash
        }
      }));
    }
  });
};

/*
   * CONFIG GEN
   */

const cmakeArrayToQuotedList = function(array) {
  const s = "";
  _.each(array, function(el, i) {
    if (i === 0) {
      return s += `\"${el}\"`;
    } else {
      return s += ` \"${el}\"`;
    }
  });
  return s;
};

const header = function() {
  return `# generated by trieMake
cmake_minimum_required(VERSION ${__guard__(this.cmake, x => x.minimumVersion) || '3.2'})
project(${this.name} VERSION ${this.version || '0.0.1'})`;
};

const boost = function() {
  if (this.boost) {
    if (typeof this.boost === 'string' || this.boost instanceof String) {
      this.boost = {
        libs: [this.boost]
      };
    }
    return `\n
      # Include BoostLib module
      SET(CMAKE_MODULE_PATH "${path.join(this.npmDir, "node_modules/boost-lib/cmake")}") include(BoostLib) # Locate/Download Boost (semver) require_boost_libs("${this.boost.version || ">= 1.59.0"}" "${this.boost.libs.join(";")}")
      include_directories(\\${Boost_INCLUDE_DIRS})`;
  }
};

const includeDirectories = function() {
  switch (this.target) {
    case 'static':
    case 'dynamic':
    case 'bin':
      return `\n
        include_directories(${cmakeArrayToQuotedList(this.includeDirs)})`;
    case 'node':
      return `\n
        # Essential include files to build a node addon,
        # you should add this line in every CMake.js based project.
        include_directories(\\${CMAKE_JS_INC})
        include_directories(${cmakeArrayToQuotedList(this.includeDirs)})`;
  }
};

const sources = function() {
  return `\n
    set(SOURCE_FILES \\${SOURCE_FILES} ${cmakeArrayToQuotedList(this.sources)})`;
};

const flags = function() {
  // linkerFlags = ""
  // switch @target
  //   when 'static'
  //     linkerFlags = "set(CMAKE_STATIC_LINKER_FLAGS \"${CMAKE_STATIC_LINKER_FLAGS} #{@linkerFlags}\")"
  //   when 'shared'
  //     linkerFlags = "set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} #{@linkerFlags}\")"
  //   when 'bin'
  //     linkerFlags = "set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} #{@linkerFlags}\")"
  return `\n
    set(CMAKE_CXX_FLAGS "\\${CMAKE_CXX_FLAGS} ${this.cxxFlags.join(' ')}")
    set(CMAKE_C_FLAGS "\\${CMAKE_C_FLAGS} ${this.cFlags.join(' ')}")`;
};

const assets = function() {
  const copy = "";
  if (__guard__(dep.build.cmake, x => x.copy)) {
    _.each(arrayify(dep.build.cmake.copy), function(ft) {
      if (fs.existsSync(`${dep.d.project}/${ft.from}`)) {
        return copy += `\nfile(COPY \${CMAKE_CURRENT_SOURCE_DIR}/${ft.from} DESTINATION \${CMAKE_CURRENT_BINARY_DIR}/${ft.to})`;
      } else {
        throw new Error(`@CMake gen -> file doesn't exist @ ${dep.d.project}/${ft.from}`);
      }
    });
  }
  return copy;
};

const target = function() {
  switch (this.target) {
    case 'static':
      return `\n
        add_library(${this.name} STATIC \\${SOURCE_FILES})`;
    case 'bin':
      return `\n
        add_executable(${this.name} \\${SOURCE_FILES})`;
  }
};

const link = function() {
  const libs = cmakeArrayToQuotedList(this.libs);
  const frameworks = cmakeArrayToQuotedList(this.frameworks);
  if (this.boost) {
    libs += " ${Boost_LIBRARIES}";
  }
  if (this.target === 'node') {
    libs += " ${CMAKE_JS_LIB}";
  }
  if (libs.length) {
    return `\n
      target_link_libraries(\\${PROJECT_NAME} ${libs} ${frameworks} ${this.linkerFlags.join(' ')})`;
  }
};

const generateLists = function(funcs, context) {
  const list = "";
  return _p(funcs, fn => Promise.resolve(fn.bind(context)()).then(function(val) {
    if (val) {
      return list += val;
    }
  })).then(() => Promise.resolve(list));
};

export default {
  generate() {
    return generateLists([
      header,
      boost,
      includeDirectories,
      sources,
      flags,
      target,
      link,
      assets
    ], dep.configuration);
  },

  configure() {
    return ninja.getNinja().then(ninjaPath => configure(ninjaPath));
  },

  build() {
    return ninja.getNinja().then(ninjaPath => configure(ninjaPath).then(() => run(ninjaPath)));
  }
};
